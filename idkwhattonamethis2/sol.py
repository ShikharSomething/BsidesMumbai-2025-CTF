# Data arrays (little-endian 64-bit integers)
data_861f0 = [
    0x01, 0x0B, 0x15, 0x1F, 0x03, 0x0D, 0x17, 0x21,
    0x05, 0x0F, 0x19, 0x23, 0x07, 0x11, 0x1B, 0x25,
    0x09, 0x13, 0x1D, 0x27, 0x29, 0x2B, 0x2D, 0x2F
]

data_862b8 = [
    0xD1, 0x4D, 0x8D, 0x1E9, 0x91, 0x9B, 0xA5, 0x0F,
    0x115, 0xF7, 0x75, 0xD1, 0x27, 0x07, 0x13F, 0x63,
    0x8B, 0x77, 0xBD, 0x29, 0x49, 0x41, 0xE7, 0x41
]

data_86380 = [
    0x55, 0xBB, 0x15, 0x18F, 0x0B, 0x1D, 0x43, 0xB1,
    0x193, 0x9F, 0xCB, 0x49, 0x8F, 0xDD, 0x1BD, 0x03,
    0x07, 0x11, 0x59, 0xC5, 0x2F, 0x99, 0x55, 0xBB
]

# Recover the input bytes
flag = [0] * 24  # Initialize with 24 bytes (since i goes up to 47 stepping by 2)

for i in range(24):
    xor_mask = data_86380[i]
    expected = data_862b8[i]
    input_pos = data_861f0[i] >> 1  # Position in input buffer

    # Reverse: ((input_byte * 2 + 1) ^ xor_mask) | 1 == expected
    # => input_byte = (((expected & ~1) ^ xor_mask) - 1) // 2
    val = (expected & ~1) ^ xor_mask
    input_byte = (val - 1) // 2
    flag[input_pos] = input_byte

# Convert to ASCII
flag_str = ''.join([chr(b) for b in flag])
print("Recovered Flag:", flag_str)